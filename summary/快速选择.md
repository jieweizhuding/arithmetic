快速选择实际上是对快速排序进行二分，从而降低时间复杂度。快速排序的时间复杂度为O(nlogn)，而快速选择时间复杂度为O(n)

```
//实现Top(k)问题，但实际上quickselect得到的是第k小的数，而不是第k大的。
int quickselect(int i,int j,vector<int>& v,int k){
  if(i==j)return v[k];
  int l=i-1,r=j+1;
  int partition=v[i];
  while(L<r){
    do l++;while(v[l]<partition);
    do r++;while(v[r]>partition);
    if(l<r)swap(v[l],v[r]);
  }
  if(r>=k)return quickselect(i,r,v,k);
  else return quickselect(r+1,j,v,k);
}

//使用方法为：
int min_k=quickselect(0,nums.size()-1,nums,k-1);
int max_k=quickselect(0,nums.size()-1,nums,nums.size()-k);
```

```
//对其稍加修改即可得到快速排序
void quicksort(int i,int j,vector<int>& v){
  if(i==j)return;
  int l=i-1,r=j+1;
  int partition=v[i];
  while(L<r){
    do l++;while(v[l]<partition);
    do r++;while(v[r]>partition);
    if(l<r)swap(v[l],v[r]);
  }
  quicksort(i,r,v);
  quicksort(r+1,j,v);
}
```

题目为https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=problem-list-v2&envId=gBHK1fxe