回溯法根据不同的要求有多种写法
主要的回溯法有两种，其核心都是dfs。
接下来介绍其模板与各种变式。


注意：下面的两个模板并不等价，有的题可以用两种方法，有的只能用特定的那个。

模板一：
从答案的角度出发(当答案的规模固定，每位的答案的可能值比较清晰时较好)
```C++
int main(){
    vector<vector<int>> ans;
    vector<int> path;

    auto dfs=[&](this auto&& dfs,int i)->void{
        if(剪枝条件){
            return;
        }
        //看是要过程中的值还是叶节点还是指明的层的值
        if(终止条件){
            return;
        }
        for(int j=0;j<map.size();j++){
            path.push_back(map[j]);
            dfs(i+1);
            path.pop_back();
        }
    };
    dfs(0);
}

```

模板二：
从每个节点的选择出发(当每个节点的可选状态较少且固定时较好)
```C++
int main(){
    vector<vector<int>> ans;
    vector<int> path;

    auto dfs=[&](this auto&& dfs,int i){
        //
        if(剪枝条件){
            return;
        }

        //看是要过程中的值还是叶节点还是指明的层的值
        if(终止条件){
            ans.push_back(path);
            return;
        }

        //第一种操作
        operate_1();
        dfs(i+1);
        //回溯
        back();

        //第二种操作
        operate_2();
        dfs(i+1);
        //回溯
        back();
    }；

    dfs(0);
}

```

上面的模板中没有写出path何时放入ans中，因为其大致位置与题目相关，
回溯法根据题目要求得到的结果大致可以分为四种：
1. 所有的子集[子集问题]
2. 叶节点的值(不需要path，不需要回溯，只需DFS即可，这里放在一起考虑了)
3. 到叶节点的路径
4. 给定深度所有值[组合问题，排列问题]

1. 对子集问题有特定的优化解法
```C++
vector<vector<int>> ans;
vector<int> path;
auto dfs=[&](this auto&& dfs,int i)->void{
    //path放入ans的位置
    ans.push_back(path);
    if(终止条件){
        return;
    }
    //这里的j=i是特定优化，防止重复
    for(int j=i;j<map.size();j++){
        path.push_back(map[j]);
        //上面j=i时，这里写成j+1,仅有这里是这种写法
        dfs(j+1);
        path.pop_back();
    }
};

    dfs(0);
```

2. 
```C++
if(终止条件){
    ans.push_back(value);
    return;
}
```

3. 
```C++
if(终止条件){
    ans.push_back(path);
    return;
}
```

4. 
```C++
if(path.size()==size){
    ans.push_back(path);
    return;
}
```