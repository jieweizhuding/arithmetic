# 总结：
回溯法是在dfs的基础上进行了现场还原的方法。
其基本模板如下：
```
#include<vector>
#include<functional>
vector<vector<int>> fun(){
    vector<vector<int>> ans;
    vector<int> path;
    function<void()> dfs=[&]()->void{
        if(剪枝){}
        if(终止条件){}
        for(int x:set){
            if(剪枝){
                path.push_back(x);
                dfs();
                path.pop_back();
            }
        }
    };
    dfs();
    return ans;
}
```

其中要点有：
1. 文中有两种剪枝，第一个是在放入path后检查，保证整体的正确性，第二个是在放入path前检查，保证局部的正确性，以达到整体的正确性，其可靠性比第一个较低，但速度与空间复杂度更优。
2. 每次考虑递归有两个主要考虑的因素：取值的set与path，由这两者可以找到终止条件与解决问题的方向。path的push与pop是改变path的值，dfs是改变子问题的set的值。
3. 关于pop的时机，我们一般认为与模板相同，当在网格图的问题中可能会有不同，我们后来再详细介绍。
4. 将path放入ans，大致有四种情况：
    1. 所有的子集[子集问题]
    2. 叶节点的值(不需要path，不需要回溯，只需DFS即可，这里放在一起考虑了)
    3. 到叶节点的路径
    4. 给定深度所有值[组合问题，排列问题]
```
1. 对子集问题有特定的优化解法
vector<vector<int>> ans;
vector<int> path;
auto dfs=[&](this auto&& dfs,int i)->void{
    //path放入ans的位置
    ans.push_back(path);
    if(终止条件){
        return;
    }
    //这里的j=i是特定优化，防止重复
    for(int j=i;j<map.size();j++){
        path.push_back(map[j]);
        //上面j=i时，这里写成j+1,仅有这里是这种写法
        dfs(j+1);
        path.pop_back();
    }
};
dfs(0);

2. 
if(终止条件){
    ans.push_back(value);
    return;
}

3. 
if(终止条件){
    ans.push_back(path);
    return;
}

4. 
if(path.size()==size){
    ans.push_back(path);
    return;
}
```

# 2025.3.10
对昨天的兄弟节点的问题有了新的考虑，在昨天，我的思路是对每个递归深度维护一个数组，将同级的每个节点的选择记录下来，但没有成功实现，并且在询问DeepSeek后，它对该方法也不赞成，可也没有提出优秀的解法。

刚刚我突然想到，可以认为左节点是右节点的父问题，则兄弟节点转化为父子节点，比如leetcode的95题，这里提供一个大概的思路
```
dfs(root){
    if(终止条件)
    for(){
        path.push(root->val);
        dfs_left(left);//处理左节点
        path.pop;
    }
}


dfs_left(node){
    if(终止条件)
    for(){
        path.push(node->val);
        dfs_left(left);
        dfs(right);
        path.pop;
    }
}

```
这仅仅是我的初步思考，即双递归或者多递归，实现兄弟转化为父子。


# 2025.3.8
截至目前，我认为回溯法的核心有两点：
1.set
2.path

且我认为两种模板是等价的，与3.3日的想法完全不同了。
我认为两种写法都可以归为一个模板，如下：
```
#include<vector>
#include<string>
#include<functional>

vector<vector<int>> fun(){
    vector<vector<int>> ans;
    vector<int> path;
    function<void()> dfs=[&](){
        if(剪枝){}
        if(终止条件){}
        for(int x:set){
            if(剪枝){
                path.push_back(x);
                dfs();
                path.pop_back();
            }
        }
    };

    dfs();
    return ans;
}
```
模板很简单，但实际困难的地方还是较多的。

且还有一个至关重要的问题，就是兄弟节点如何传参。
还有父对子传参，一般更倾向于传递参数还是维护全局变量。

首先回答父子传参的问题，我认为一般情况下，该问题是对拷贝的时间与对数据的恢复的复杂度的比较，即选择传递参数会多次拷贝，但可以轻易恢复，而全局变量唯一但需要找到合适的方法恢复数据。当然我们接触的一般情况是参数较小且易于恢复的，此时选哪个都无所谓。

# 2025.3.6
重新思考了一下，发现终止条件大概可以统一为当取值set为空时终止。
但还有一些问题：
1. 什么时候pop
2. 如果可以选择空元素如何处理
3. 多维回溯法的解法

对1解答：
在模板一中我们发现每次dfs后都要pop，但在模板二中有时不需pop多次，甚至pop后还是错误的。
区别在与push的时机不同。



# 2025.3.5
我认为回溯法的重点有三个：
1.终止条件
2.取值集合
3.path处理

对终止条件：
终止条件并不只是规定递归何时终止，更重要的是，其反映了递归的方向，即保证了问题的可结束性。确定了正确的结束条件才能找到正确反映递归深度的值。

终止条件没有固定的套路，都来自于题中，但有两种办法简化思考。
1.靠经验：大部分的题目的终止条件都是类似的，如答案的位数，集合的位数，叶节点终止等等。
2.试一试：在dfs(0)(即递归深度为0)时，我们一定已知取值的set，且此时path为空。
我们不妨取集合中的一个符合题意的值放入path中，进入dfs(1)。(注意：如果允许不选set中的值，是一种特殊的情况，有特殊的写法)
此时观察都有哪些量发生了变化。
如我们上面提到的三种：
path的size改变->答案的位数
set的大小缩减->集合的位数
set的值改变->叶节点终止



# 2025.3.3
回溯法根据不同的要求有多种写法
主要的回溯法有两种，其核心都是dfs。
接下来介绍其模板与各种变式。

注意：下面的两个模板并不等价，有的题可以用两种方法，有的只能用特定的那个。
## 模板
模板一：
从答案的角度出发(当答案的规模固定，每位的答案的可能值比较清晰时较好)
```C++
int main(){
    vector<vector<int>> ans;
    vector<int> path;

    //注意这里的写法在C++23标准中才支持，如果编译器不支持可以换成下面的语法：
    /*  #include<functional>

        function<void(int)> dfs=[&](int i){};

        dfs(0);
    */
    auto dfs=[&](this auto&& dfs,int i)->void{
        if(剪枝条件){
            return;
        }
        //看是要过程中的值还是叶节点还是指明的层的值
        if(终止条件){
            return;
        }
        for(int j=0;j<map.size();j++){
            path.push_back(map[j]);
            dfs(i+1);
            path.pop_back();
        }
    };
    dfs(0);
}

```

模板二：
从每个节点的选择出发(当每个节点的可选状态较少且固定时较好)
```C++
int main(){
    vector<vector<int>> ans;
    vector<int> path;

    auto dfs=[&](this auto&& dfs,int i){
        //
        if(剪枝条件){
            return;
        }

        //看是要过程中的值还是叶节点还是指明的层的值
        if(终止条件){
            ans.push_back(path);
            return;
        }

        //第一种操作
        operate_1();
        dfs(i+1);
        //回溯
        back();

        //第二种操作
        operate_2();
        dfs(i+1);
        //回溯
        back();
    }；

    dfs(0);
}

```

## path取值

上面的模板中没有写出path何时放入ans中，因为其大致位置与题目相关，
回溯法根据题目要求得到的结果大致可以分为四种：
1. 所有的子集[子集问题]
2. 叶节点的值(不需要path，不需要回溯，只需DFS即可，这里放在一起考虑了)
3. 到叶节点的路径
4. 给定深度所有值[组合问题，排列问题]

1. 对子集问题有特定的优化解法
```C++
vector<vector<int>> ans;
vector<int> path;
auto dfs=[&](this auto&& dfs,int i)->void{
    //path放入ans的位置
    ans.push_back(path);
    if(终止条件){
        return;
    }
    //这里的j=i是特定优化，防止重复
    for(int j=i;j<map.size();j++){
        path.push_back(map[j]);
        //上面j=i时，这里写成j+1,仅有这里是这种写法
        dfs(j+1);
        path.pop_back();
    }
};

    dfs(0);
```

2. 
```C++
if(终止条件){
    ans.push_back(value);
    return;
}
```

3. 
```C++
if(终止条件){
    ans.push_back(path);
    return;
}
```

4. 
```C++
if(path.size()==size){
    ans.push_back(path);
    return;
}
```


技巧：89--提前终止



