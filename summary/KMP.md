因为一道题需要用到KMP算法，故复习了一下。
KMP算法的精髓在于添加了next数组，因此理解next数组的意义就是该算法的核心。

这里我们称等待被匹配的较长的字符串为目标字符串，用于匹配的短的字符串为模板字符串。
#### next数组的定义大致为：
next[i]=k，即模板字符串的前i位(意为当前在第i位的字符串不用被考虑进去)的子字符串的最大前缀与后缀的重合长度，如
 a a b c a a b
-1 0 1 0 0 1 2

#### 首先KMP算法的大致流程为：
用i,j两个索引分别指向目标字符串和模板字符串的头的位置，并比较对应位置的元素是否相同，如果相同则i,j同时自增1个单位，若不同，则i不变，j=next[j]，并重现开始比较，重复以上流程。
若j=-1，则i++，j++。当i达到目标字符串的尾部时依然没有对应成功，则没有模板字符串。

#### KMP算法如何保证不重不漏
1. 不漏：
next数组为最长重复前后缀的值
#### 我们考虑next数组怎么求解：
由定义可知next[0]=-1,next[1]=0,
假设
$$
next[j-1]=k
$$
$$
[\underline{a_0\ a_1\ a_2\ ...\ a_{k-1}}\ a_k\ ......\underline{a_{j-k-1}\ ...\ a_{j-2}}\ a_{j-1}\ a_j]
$$
画下划线的部分完全相同

1. 若$arr[j-1]=arr[k]$，
则$next[j]=k+1$
2. 若$arr[j-1]\neq arr[k]$，
则我们先考虑如下引理：
    1. 在