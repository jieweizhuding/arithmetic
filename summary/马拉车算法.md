马拉车算法是实现求出字符串所有连续子串的最长回文串的算法。时间复杂度为O(n)

解释视频有：【马拉车算法 | Coding Club】 https://www.bilibili.com/video/BV1Sx4y1k7jG/?share_source=copy_web&vd_source=897677428a7edfa0638cc3b6e1a1b405





``` C++
//因为字符串长度为奇数或偶数对讨论有较大的影响，为了统一，给所有的字符串开头与结尾，以及每个字符间添加一个不会出现的字符如'#'
string insert_partiton(string s){
  int size=s.size();
  string res;
  for(int i=0;i<size;i++){
    res+="#";
    res+=s[i];
  }
  res+="#";
  return res;
}

//s为添加了分隔符的字符串
vector<int> manacher(string s){
  vector<int> p(s.size());
  int c=0,r=0;
  for(int i=1;i<size-1;i++){
    if(i<=r)p[i]=min(r-i,p[2*c-i]);

    //这一部分可以去掉left与right的定义
    int left=i-p[i]-1,right=i+p[i]+1;
    while(left>=0&&right<size&&s[left]==s[right]){
      p[i]++;
      left=i-p[i]-1;
      right=i+p[i]+1;
    };

    //写成如下形式，更简单，但不易理解
    //while(i-p[i]-1>=0&&i+p[i]+1<s.size()&&s[i-p[i]-1]==s[i+p[i]+1])p[i]++;

    if(i+p[i]>r){
      r=i+p[i];
      c=i;
    }
  }
  return p;
}

```

得到的结果数组为p,p[i]=k,代表以插入分隔符的字符串的第i位为中心的最长回文串长度为k，若k为偶数，代表第i位是分隔符，否则第i位不是分隔符。

要求所有的回文串的个数(等价于求字符串所有的子串中是回文串的个数)，只需求每一位的半径大小，求和即可。
```
int ans=0;
for(int i=1;i<size-1;i++){
  //求半径
  ans+=(p[i]+1)/2;
}
```